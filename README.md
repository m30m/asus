## Running the project:

Create a `python 3` virtual environment.

Install the requirements by `pip install -r requirements`

Run the project by:

`python app.py`


## Object Entities

### Device
Represent a general device, which may be an Actuator or a Sensor. This object entity possesses the following attributes: `device_id`, `state_type` and `value_range`. The `state_type` can be `continuous` or `discrete`. 

The `value_range` for `discrete` types is captured by a python `list`.

The `value_range` for `continuous` type is captured either by a `tuple` specifying `min` and `max` as `(min, max)` or by `None`, which indicates the variable can contain any real number.

### Actuator

This class inherits `Device` and most notably implements the function `set_state`, which allows the central server to update an actuator's status. The update is only executed after checking the assigned value is of the appropriate `state_type` and within the relevant `value_range`.

`Door` and `Lamp` are entities inheriting from the `Actuator` class and representing the project's actuators.

### Sensor:

This class inherits the device and most notably implements the function `recieve_state`, which allows the central server to update its perception of the environment based on the received sensory input from the connected clients.

`Proximity`, `Noise`, and `Motion` are entities inheriting `Sensor` representing the sensors defined in the project.

Note: All instances of `Sensor` and `Actuator`, namely `Door`, `Lamp`, `Proximity`, `Noise`, and `Motion` implement a `build_rule` function which specifies for our front end and rule engine the representation rules for these entities.

## Client/Server communication

### Overal Summary

The clients which correspond to IoT objects wheter actuotors or sensors are implemented as web pages each corresponding to an independent process. For the implementation of the clients and also the client/server communication we have used the following libraries: `Vue.js`, `Semantic`, `Flask` and `Websocket`.
The server is mainly implemented in `app.py` and handles the request generated by clients in the backend.

### Initializing Communication Channel

First, the client sends a `init` message with `type` of the state and its `value`.

Once this request is received by the server in the function `init` an instance of the `Device` class will be created using the request id from the websocket as `device_id`, `type` as`state_type` and `value` as the initial `state` and stored.

This object is used for all further server/client interactions and also in the rule engine. 

Note: the function `init` calls within it the function `update_admin` which updates the user interface of the admin panel of our server with the created device if necessesary.

### Updating/Recieving States: 

If the value corresponding to the state of a device whether an actuator or sensor is changed and event listener within our clients will trigger the function`update_state`in `app.py` which applies the corresponding update in the backend appropirately.

Note: As soon as the state of a device changes we check using our implemented rule engine the rules associated with or including that device and then re-evaluate the rules; firing(executing) the appropirate actions. 

## Rule Engine



